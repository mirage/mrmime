<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Enclosure (mrmime.Prettym__.Enclosure)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">mrmime</a> &#x00BB; <a href="../index.html">Prettym__</a> &#x00BB; Enclosure</nav><h1>Module <code>Prettym__.Enclosure</code></h1></header><aside><p><code>Enclosure</code> module follows <code>Faraday</code> implementation (thx @spiros). The main difference is: <code>Enclosure</code> uses a bounded internal <code>Bigstringaf.t</code> which can not be grow. Internal queue which contains <code>IOVec</code> elements can not grow too.</p><p>By this way, we ensure that <code>encoder</code> uses a bounded memory area. Where <code>encoder</code> is full, any operation returns <code>Flush</code>. User should emit <code>IOVec</code> then to output.</p><p>XXX(dinosaure): Faraday's cage is an enclosure.</p></aside><div class="spec module" id="module-Buffer"><a href="#module-Buffer" class="anchor"></a><code><span class="keyword">module</span> <a href="Buffer/index.html">Buffer</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-IOVec"><a href="#module-IOVec" class="anchor"></a><code><span class="keyword">module</span> <a href="IOVec/index.html">IOVec</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-encoder"><a href="#type-encoder" class="anchor"></a><code><span class="keyword">type</span> encoder</code></dt><dd><p>The type of encoder.</p></dd></dl><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <a href="index.html#type-encoder">encoder</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_empty t</code> returns <code>true</code> if nothing is under <code>t</code>. This case appear afterwards a <a href="index.html#val-flush"><code>flush</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <span><a href="index.html#type-encoder">encoder</a> Fmt.t</span></code></dt><dd><p>Pretty-printer of <a href="index.html#type-encoder"><code>encoder</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-schedule_flush"><a href="#val-schedule_flush" class="anchor"></a><code><span class="keyword">val</span> schedule_flush : <span>(int <span>&#45;&gt;</span> <a href="index.html#type-encoder">encoder</a> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <a href="index.html#type-encoder">encoder</a> <span>&#45;&gt;</span> <a href="index.html#type-encoder">encoder</a></code></dt><dd><p><code>schedule_flush f encoder</code> registers <code>f</code> to be called when all prior writes have been successfully completed. If <code>encoder</code> has no pending writes, then <code>f</code> will be called immediately.</p></dd></dl><dl><dt class="spec value" id="val-schedule_bigstring"><a href="#val-schedule_bigstring" class="anchor"></a><code><span class="keyword">val</span> schedule_bigstring : <a href="index.html#type-encoder">encoder</a> <span>&#45;&gt;</span> <span>?&#8288;off:int</span> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> Bigstringaf.t <span>&#45;&gt;</span> <a href="index.html#type-encoder">encoder</a></code></dt><dd><p><code>schedule_bigstring t ?off ?len a</code> stores a pointer to <code>a</code> into the serializer's internal queue.</p></dd></dl><dl><dt class="spec value" id="val-kschedule_bigstring"><a href="#val-kschedule_bigstring" class="anchor"></a><code><span class="keyword">val</span> kschedule_bigstring : <span>(<a href="index.html#type-encoder">encoder</a> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-encoder">encoder</a> <span>&#45;&gt;</span> <span>?&#8288;off:int</span> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> Bigstringaf.t <span>&#45;&gt;</span> <span class="type-var">'r</span></code></dt><dd><p><code>kschedule_bigstring k t ?off ?len a</code>: <code>k</code>ontinuation-style of <a href="index.html#val-schedule_bigstring"><code>schedule_bigstring</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-schedule_string"><a href="#val-schedule_string" class="anchor"></a><code><span class="keyword">val</span> schedule_string : <a href="index.html#type-encoder">encoder</a> <span>&#45;&gt;</span> <span>?&#8288;off:int</span> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-encoder">encoder</a></code></dt><dd><p>Same as <a href="index.html#val-schedule_bigstring"><code>schedule_bigstring</code></a> but for <code>String.t</code>.</p></dd></dl><dl><dt class="spec value" id="val-kschedule_string"><a href="#val-kschedule_string" class="anchor"></a><code><span class="keyword">val</span> kschedule_string : <span>(<a href="index.html#type-encoder">encoder</a> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-encoder">encoder</a> <span>&#45;&gt;</span> <span>?&#8288;off:int</span> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> Stdlib.String.t <span>&#45;&gt;</span> <span class="type-var">'r</span></code></dt><dd><p><code>kschedule_string k t ?off ?len a</code>: <code>k</code>ontinuation-style of <a href="index.html#val-schedule_string"><code>schedule_string</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-schedule_bytes"><a href="#val-schedule_bytes" class="anchor"></a><code><span class="keyword">val</span> schedule_bytes : <a href="index.html#type-encoder">encoder</a> <span>&#45;&gt;</span> <span>?&#8288;off:int</span> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> <a href="index.html#type-encoder">encoder</a></code></dt><dd><p>Same as <a href="index.html#val-schedule_bigstring"><code>schedule_bigstring</code></a> but for <code>Bytes.t</code>.</p></dd></dl><dl><dt class="spec value" id="val-kschedule_bytes"><a href="#val-kschedule_bytes" class="anchor"></a><code><span class="keyword">val</span> kschedule_bytes : <span>(<a href="index.html#type-encoder">encoder</a> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-encoder">encoder</a> <span>&#45;&gt;</span> <span>?&#8288;off:int</span> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> Stdlib.Bytes.t <span>&#45;&gt;</span> <span class="type-var">'r</span></code></dt><dd><p><code>kschedule_bytes k t ?off ?len a</code>: <code>k</code>ontinuation-style of <a href="index.html#val-schedule_bytes"><code>schedule_bytes</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-write_char"><a href="#val-write_char" class="anchor"></a><code><span class="keyword">val</span> write_char : char <span>&#45;&gt;</span> <a href="index.html#type-encoder">encoder</a> <span>&#45;&gt;</span> <a href="index.html#type-encoder">encoder</a></code></dt><dd><p><code>write_char chr t</code> copies <code>chr</code> into the serializer's internal buffer.</p></dd></dl><dl><dt class="spec value" id="val-write_string"><a href="#val-write_string" class="anchor"></a><code><span class="keyword">val</span> write_string : <span>?&#8288;off:int</span> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-encoder">encoder</a> <span>&#45;&gt;</span> <a href="index.html#type-encoder">encoder</a></code></dt><dd><p><code>write_string ?off ?len x t</code> copies <code>x</code> into the serializer's internal buffer.</p></dd></dl><dl><dt class="spec value" id="val-write_bigstring"><a href="#val-write_bigstring" class="anchor"></a><code><span class="keyword">val</span> write_bigstring : <span>?&#8288;off:int</span> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> Bigstringaf.t <span>&#45;&gt;</span> <a href="index.html#type-encoder">encoder</a> <span>&#45;&gt;</span> <a href="index.html#type-encoder">encoder</a></code></dt><dd><p>Same as <a href="index.html#val-write_string"><code>write_string</code></a> but for <code>bigstring</code>.</p></dd></dl><dl><dt class="spec value" id="val-write_bytes"><a href="#val-write_bytes" class="anchor"></a><code><span class="keyword">val</span> write_bytes : <span>?&#8288;off:int</span> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> <a href="index.html#type-encoder">encoder</a> <span>&#45;&gt;</span> <a href="index.html#type-encoder">encoder</a></code></dt><dd><p>Same as <a href="index.html#val-write_string"><code>write_string</code></a> but for <code>Bytes.t</code>.</p></dd></dl><dl><dt class="spec value" id="val-write_uint8"><a href="#val-write_uint8" class="anchor"></a><code><span class="keyword">val</span> write_uint8 : int <span>&#45;&gt;</span> <a href="index.html#type-encoder">encoder</a> <span>&#45;&gt;</span> <a href="index.html#type-encoder">encoder</a></code></dt><dd><p><code>write_uint8 x t</code> copies the lower 8 bits of <code>x</code> into the serializer's internal buffer.</p></dd></dl><dl><dt class="spec value" id="val-flush"><a href="#val-flush" class="anchor"></a><code><span class="keyword">val</span> flush : <span>(<a href="index.html#type-encoder">encoder</a> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-encoder">encoder</a> <span>&#45;&gt;</span> <span class="type-var">'r</span></code></dt><dd><p><code>flush k encoder</code> enforces to flush at this stage <code>encoder</code>. Then, when end-user flushes <code>encoder</code>, <code>k</code> will be called with the new state of <code>encoder</code> drained.</p></dd></dl><div class="spec module" id="module-LE"><a href="#module-LE" class="anchor"></a><code><span class="keyword">module</span> <a href="LE/index.html">LE</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-BE"><a href="#module-BE" class="anchor"></a><code><span class="keyword">module</span> <a href="BE/index.html">BE</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-emitter"><a href="#type-emitter" class="anchor"></a><code><span class="keyword">type</span> emitter</code><code> = <span><a href="IOVec/index.html#type-t">IOVec.t</a> list</span> <span>&#45;&gt;</span> int</code></dt></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <span>emitter:<a href="index.html#type-emitter">emitter</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-encoder">encoder</a></code></dt><dd><p><code>create ~emitter len</code> creates a serializer with a fixed-length internal buffer. When internal buffers are full, <code>encoder</code> calls <code>emitter</code> to emit <code>IOVec.t list</code>.</p></dd></dl></div></body></html>